// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package proof

import (
	"execution-service/hash"
	"execution-service/instance"
	"execution-service/model"
	"execution-service/proof/circuit"
	"execution-service/signature"
	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/backend/groth16"
	"github.com/consensys/gnark/frontend"
)

// Injectors from proof_service.go:

func InitializeProofService(modelPort model.ModelPort) ProofService {
	proofParameters := NewProofParameters()
	instanceService := instance.NewInstanceService()
	hashService := hash.NewHashService()
	signatureService := signature.InitializeSignatureService()
	proofService := NewProofService(proofParameters, modelPort, instanceService, hashService, signatureService)
	return proofService
}

// proof_service.go:

type ProofService struct {
	proofParameters  ProofParameters
	modelPort        model.ModelPort
	InstanceService  instance.InstanceService
	HashService      hash.HashService
	signatureService signature.SignatureService
}

func NewProofService(proofParameters ProofParameters, modelPort model.ModelPort, instanceService instance.InstanceService, hashService hash.HashService, signatureService signature.SignatureService) ProofService {
	return ProofService{
		proofParameters:  proofParameters,
		modelPort:        modelPort,
		InstanceService:  instanceService,
		HashService:      hashService,
		signatureService: signatureService,
	}
}

func (service *ProofService) ProveInstantiation(cmd ProveInstantiationCommand) (Proof, error) {
	model2, err := service.modelPort.FindModelById(cmd.Model)
	if err != nil {
		return Proof{}, err
	}
	modelHash, err := service.HashService.FindHashByModelId(model2.Id)
	if err != nil {
		return Proof{}, err
	}
	instance2, err := service.InstanceService.FindInstanceById(cmd.Instance)
	if err != nil {
		return Proof{}, err
	}
	signature2 := service.signatureService.Sign(instance2)
	assignment := &circuit.InstantiationCircuit{
		ModelHash: circuit.FromHash(modelHash),
		Model:     circuit.FromModel(model2),
		Instance:  circuit.FromInstance(instance2),
		Signature: circuit.FromSignature(signature2),
	}
	witness, err := frontend.NewWitness(assignment, ecc.BN254.ScalarField())
	if err != nil {
		return Proof{}, err
	}
	proof, err := groth16.Prove(service.proofParameters.CsInstantiation, service.proofParameters.PkInstantiation, witness)
	if err != nil {
		return Proof{}, err
	}
	return newProof(proof, witness)
}

func (service *ProofService) ProveTransition(cmd ProveTransitionCommand) (Proof, error) {
	model2, err := service.modelPort.FindModelById(cmd.Model)
	if err != nil {
		return Proof{}, err
	}
	modelHash, err := service.HashService.FindHashByModelId(model2.Id)
	if err != nil {
		return Proof{}, err
	}
	currentInstance, err := service.InstanceService.FindInstanceById(cmd.CurrentInstance)
	if err != nil {
		return Proof{}, err
	}
	nextInstance, err := service.InstanceService.FindInstanceById(cmd.NextInstance)
	if err != nil {
		return Proof{}, err
	}
	signature2 := service.signatureService.Sign(nextInstance)
	assignment := &circuit.TransitionCircuit{
		ModelHash:             circuit.FromHash(modelHash),
		Model:                 circuit.FromModel(model2),
		CurrentInstance:       circuit.FromInstance(currentInstance),
		NextInstance:          circuit.FromInstance(nextInstance),
		NextInstanceSignature: circuit.FromSignature(signature2),
	}
	witness, err := frontend.NewWitness(assignment, ecc.BN254.ScalarField())
	if err != nil {
		return Proof{}, err
	}
	proof, err := groth16.Prove(service.proofParameters.CsTransition, service.proofParameters.PkTransition, witness)
	if err != nil {
		return Proof{}, err
	}
	return newProof(proof, witness)
}

func (service *ProofService) ProveTermination(cmd ProveTerminationCommand) (Proof, error) {
	model2, err := service.modelPort.FindModelById(cmd.Model)
	if err != nil {
		return Proof{}, err
	}
	modelHash, err := service.HashService.FindHashByModelId(model2.Id)
	if err != nil {
		return Proof{}, err
	}
	instance2, err := service.InstanceService.FindInstanceById(cmd.Instance)
	if err != nil {
		return Proof{}, err
	}
	signature2 := service.signatureService.Sign(instance2)
	assignment := &circuit.TerminationCircuit{
		ModelHash: circuit.FromHash(modelHash),
		Model:     circuit.FromModel(model2),
		Instance:  circuit.FromInstance(instance2),
		Signature: circuit.FromSignature(signature2),
	}
	witness, err := frontend.NewWitness(assignment, ecc.BN254.ScalarField())
	if err != nil {
		return Proof{}, err
	}
	proof, err := groth16.Prove(service.proofParameters.CsTermination, service.proofParameters.PkTermination, witness)
	if err != nil {
		return Proof{}, err
	}
	return newProof(proof, witness)
}
